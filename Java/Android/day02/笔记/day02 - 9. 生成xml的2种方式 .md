#9. 生成xml的2种方式 
	

	1.写布局

	2.业务逻辑
		a.备份
			1.封装短信数据到list中
			2.将list中的数据写到xml文件中。
		b.恢复
			1.解析xml文件中短信数据，封装到list集合中
			2.将解析数据打印。


	XmlSerializer
	


	//使用XmlSerializer来序列化xml文件
	public static boolean backupSms_android(Context context){
		
		try{
			
			//0.获取短信数据
			ArrayList<SmsBean> allSms = SmsDao.getAllSms();
			//1.通过Xml获取一个XmlSerializer对象
			XmlSerializer xs = Xml.newSerializer();
			//2.设置XmlSerializer的一些参数，比如：设置xml写入到哪个文件中
			//os:xml文件写入流   encoding：流的编码
			xs.setOutput(context.openFileOutput("backupsms2.xml", Context.MODE_PRIVATE), "utf-8");
			//3.序列化一个xml的声明头
			//encoding:xml文件的编码  standalone:是否独立
			xs.startDocument("utf-8", true);
			//4.序列化一个根节点的开始节点
			//namespace:命名空间  name： 标签的名称
			xs.startTag(null, "Smss");
			//5.循环遍历list集合序列化一条条短信
			
				for (SmsBean smsBean : allSms) {
					xs.startTag(null, "Sms");
					//name:属性的名称  value：属性值
					xs.attribute(null, "id", smsBean.id+"");
					
					xs.startTag(null, "num");
					//写一个标签的内容
					xs.text(smsBean.num);
					xs.endTag(null, "num");
					
					
					xs.startTag(null, "msg");
					xs.text(smsBean.msg);
					xs.endTag(null, "msg");
					
					
					xs.startTag(null, "date");
					xs.text(smsBean.date);
					xs.endTag(null, "date");
					
					xs.endTag(null, "Sms");
				}

			//6.序列化一个根节点的结束节点
				xs.endTag(null, "Smss");
			//7.将xml写入到文件中，完成xml的序列化
				xs.endDocument();
				return true;

		}catch (Exception e) {
			e.printStackTrace();
		}
		return false;
	}